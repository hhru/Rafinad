import Foundation

/// Базовая accessibility-схема для всех UI-компонентов.
///
/// Accessibility-схема - это вспомогательный тип для тестируемого UI-компонента,
/// который позволяет описывать структуру и возможности компонента для тестов.
///
/// Тесты используют accessibility-схему для поиска вложенных элементов UI-компонента
/// и выполнения действий над ними, используя сущность ``TestingElement``.
///
/// Существует 5 основных встроенных классов accessibility-схем:
/// - ``ViewAccessibility``: базовая схема для описания всех компонентов
/// - ``TextAccessibility``: схема стандартных текстовых компонентов
/// - ``ImageAccessibility``: cхема стандартных компонентов изображений
/// - ``AnyAccessibility``: cхема компонентов с неизвестным типом
/// - ``ScreenAccessibility``: базовая схема экрана
///
/// Этого набора достаточно, чтобы описывать структуру любого UI-компонента и экрана в целом,
/// насколько это позволяет сама система и платформа.
///
///
/// ## Примитивные компоненты
///
/// В самом простейшем случае accessibility-схема представляет из себя пустой класс,
/// наследующий базовый `ViewAccessibility`, например:
///
/// ``` swift
/// // Простейший компонент, который отображает разделитель в виде серой линии
/// struct Divider: View {
///
///     var body: some View {
///         Color
///             .gray
///             .frame(height: 1)
///             .frame(maxWidth: .infinity)
///     }
/// }
///
/// // Простейшая accessibility-схема компонента
/// class DividerAccessibility: ViewAccessibility { }
/// ```
///
/// В этом примере отдельная схема `DividerAccessibility` может быть полезна
/// лишь для консистентности и потенциального масштабирования переиспользуемого компонента,
/// например, в случае компонента дизайн-системы. Если таких требований нет,
/// то он может быть легко заменен самим базовым классом `ViewAccessibility` по месту использования.
///
///
/// ## Составные компоненты
///
/// Для описания accessibility-схемы более сложных компонентов, которые состоят из других компонентов,
/// необходимо перечислить их составные элементы в виде свойств с соответствующими типами
/// и установить accessibility-ключи для этих элементов, используя ``AccessibilityKey``, например:
///
/// ``` swift
/// // Составной компонент, который отображает ячейку с заголовком,
/// // подзаголовком и опциональным разделителем
/// struct Cell: View {
///
///     let title: String
///     let subtitle: String
///     let divider: Divider?
///
///     var body: some View {
///         VStack(alignment: .leading, spacing: .zero) {
///             VStack(alignment: .leading, spacing: 4) {
///                 Text(title)
///                     .font(.title2)
///                     .foregroundStyle(.primary)
///                     // Установка ключа для заголовка
///                     .accessibilityKey(\CellAccessibility.title)
///
///                 Text(subtitle)
///                     .font(.title3)
///                     .foregroundStyle(.secondary)
///                     // Установка ключа для подзаголовка
///                     .accessibilityKey(\CellAccessibility.subtitle)
///             }
///             .padding(16)
///             .frame(maxWidth: .infinity, alignment: .leading)
///
///             divider?
///                 // Установка ключа для опционального разделителя
///                 .accessibilityKey(\CellAccessibility.divider)
///         }
///         // Создание accessibility-контейнера, чтобы находить стек в тестах
///         .accessibilityElement(children: .contain)
///     }
/// }
///
/// // Accessibility-схема составного компонента
/// class CellAccessibility: ViewAccessibility {
///
///     let title = TextAccessibility()
///     let subtitle = TextAccessibility()
///     let divider = DividerAccessibility()
/// }
/// ```
///
/// Заголовок и подзаголовок в схеме этого примера имеют тип встроенной схемы ``TextAccessibility``,
/// который используется для описания стандартных строковых компонентов.
/// Разделитель `divider` демонстрирует использование кастомной схемы `DividerAccessibility`,
/// которая была добавлена в прошлом примере.
///
/// > Important: SwiftUI исключает контейнеры (`HStack`, `VStack`, `Group` и т.д.) из иерархии accessibility-элементов,
/// при этом установленный снаружи идентификатор заменяет идентификаторы их внутренних компонентов.
/// Поэтому, если компонент отображает несколько элементов через стек или другой контейнер,
/// то для доступа  к нему в тестах следует создать accessibility-элемент самостоятельно,
/// используя модификатор `.accessibilityElement(children: .contain)`.
///
/// > Important: Если какое-либо свойство в accessibility-схеме имеет тип `ViewAccessibility` или его наследников,
/// то для его элемента обязательно должен быть установлен accessibility-ключ в самом UI-компоненте,
/// так как ``TestingElement`` будет пытаться найти для него объект `XCUIElement` в иерархии.
///
/// > Tip: Если тип свойства в accessibility-схеме не связан с `ViewAccessibility` или его наследниками,
/// то его элемент считается **группирующим** и для него не нужно устанавливать accessibility-ключ,
/// так как ``TestingElement`` не будет искать для него объект `XCUIElement` в иерархии.
///
/// Если составной компонент переиспользуемый, например, в случае компонента дизайн-системы,
/// то схема этого компонента чаще всего будет зависеть от его наружного интерфейса,
/// так как остальной контент статичен и не представляет интереса в тестах.
/// Например, если разделитель `divider` отсутствует в наружном интерфейсе компонента `Cell`
/// и отображается всегда без условий, то нет смысла проверять его в тестах,
/// а значит нет нужды описывать его в схеме `CellAccessibility`.
///
///
/// ## Компоненты со списками
///
/// Если в компоненте отображается какой-либо список элементов (стек, таблица, сетка и т.д.),
/// то соответствующее поле в его accessibility-схеме объявляется через массив, например:
///
/// ``` swift
/// // Компонент, который отображает список тегов
/// struct Tags: View {
///
///     let items: [String]
///
///     var body: some View {
///         HStack(spacing: 8) {
///             ForEach(items, id: \.self) { tag in
///                 Text(tag)
///                     .font(.subheadline)
///                     .padding(8)
///                     .background(.quinary)
///                     .clipShape(.rect(cornerRadius: 8))
///                     // Установка ключа для элемента списка с его уточнением
///                     .accessibilityKey(\TagsAccessibility.items, item: tag)
///             }
///         }
///         // Создание accessibility-контейнера, чтобы находить стек в тестах
///         .accessibilityElement(children: .contain)
///     }
/// }
///
/// // Accessibility-схема компонента со списком
/// class TagsAccessibility: ViewAccessibility {
///
///     let items = [TextAccessibility]()
/// }
/// ```
///
/// В этом примере устанавливается accessibility-ключ с уточняющим параметром `item`,
/// в который передается строка - названия тега. Такое уточнение возможно только для массивов
/// и позволяет в тестах получать элементы списка не только через их индекс, но и через эту уточняющую строку.
/// Параметр `item` опционален, можно установить accessibility-ключ и без него,
/// но тогда в тестах элементы списка будут доступны только через их индекс.
///
///
/// ## Компоненты неизвестного типа
///
/// Иногда компоненты могут отображать другие компоненты с неизвестным типом,
/// например, под generic-типом или типом `AnyView`.
/// Чтобы объявить поле для такого контента в accessibility-схеме,
/// необходимо использовать тип ``AnyAccessibility``, например:
///
/// ``` swift
/// // Компонент, который отображает фото из заданного URL
/// // или любой заполнитель под generic-типом
/// struct Avatar<Placeholder: View>: View {
///
///     let url: URL?
///     let placeholder: Placeholder
///
///     var body: some View {
///         AsyncImage(url: url) { image in
///             image
///                 .resizable()
///                 // Установка ключа для фото из URL
///                 .accessibilityKey(\AvatarAccessibility.image)
///         } placeholder: {
///             placeholder
///                 // Установка ключа для заполнителя с неизвестным типом
///                 .accessibilityKey(\AvatarAccessibility.placeholder)
///         }
///         .frame(width: 40, height: 40)
///         .clipShape(.capsule)
///         // Создание accessibility-контейнера, чтобы находить элемент в тестах
///         .accessibilityElement(children: .contain)
///     }
/// }
///
/// // Accessibility-схема компонента с контентом неизвестного типа
/// class AvatarAccessibility: ViewAccessibility {
///
///     let image = ImageAccessibility()
///     let placeholder = AnyAccessibility()
/// }
/// ```
///
/// В этом примере конкретный тип поля `placeholder` будет неизвестен заранее,
/// но его можно уточнить для экземпляра ``TestingElement`` по месту в тестах.
/// Без уточнения типа для этого поля будет доступен только базовый набор действий.
///
///
/// ## Возможности компонента
///
/// Кроме структуры компонента, accessibility-схема также определяет набор его возможностей для тестов,
/// например, возможность обрабатывать отключенное состоятие, редактировать текст и т.д.
/// В отличие от стандартного подхода в `XCUIElement` такое решение позволяет обезопасить
/// код проверок в тестах на этапе компиляции, не позволяя выполнять специфичные действия для компонента,
/// который их не поддерживает, например, пытаться вводить текст для кнопки.
///
/// Встроенные схемы уже имеют определенный набор доступных полей в тестах для сущности ``TestingElement``,
/// но эти поля могут быть расширены с помощью слоя протоколов с дополнительными возможностями:
/// - ``DisableableAccessibility``: добавляет возможность обрабатывать отключенное состояние
/// - ``SelectableAccessibility``: добавляет возможность обрабатывать выбранное состояние
/// - ``EditableAccessibility``: добавляет возможность редактирования текста
/// - ``SwipeableAccessibility``: добавляет возможность выполнять жесты свайпа
/// - ``RotatableAccessibility``: добавляет возможность выполнять жесты поворота
/// - ``PinchableAccessibility``: добавляет возможность выполнять жесты масштабирования
///
/// Чтобы задекларировать дополнительные возможности компонента для тестов,
/// достаточно подписать его accessibility-схему под соответствующие протоколы, например:
///
/// ``` swift
/// class CheckboxAccessibility:
///     ViewAccessibility,
///     DisableableAccessibility,
///     SelectableAccessibility { }
/// ```
///
/// В этом примере для экземпляра ``TestingElement`` в тестах, кроме базового набора,
/// станут доступны дополнительные поля для обработки отключенного и выбранного состояний компонента.
///
///
/// ## Стандартные компоненты
///
/// В наборе встроенных accessibility-схем отсутствуют типы для многих стандартных компонентов SwiftUI и UIKit,
/// так как эти компоненты чаще всего кастомизируются и оборачиваются в переиспользуемое решение.
/// Но в случае необходимости accessibility-схема стандартного компонента может быть легко добавлена
/// самостоятельно комбинацией базового класса и протоколов его дополнительных возможностей, например:
///
/// ``` swift
/// class TextFieldAccessibility:
///     ViewAccessibility,
///     EditableAccessibility,
///     DisableableAccessibility { }
/// ```
///
/// Такой подход позволяет избежать лишних конфликтов имен в случае наличия кастомных компонентов,
/// которые часто дублируют названия стандартных, например, в случае компонентов дизайн-системы.
///
///
/// ## See Also
///
/// - ``TextAccessibility``
/// - ``ImageAccessibility``
/// - ``AnyAccessibility``
/// - ``ScreenAccessibility``
/// - ``AccessibilityKey``
/// - ``TestingElement``
open class ViewAccessibility {

    /// Создает экземпляр accessibility-схемы.
    public required init() { }
}
